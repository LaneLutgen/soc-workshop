From d9f93cb77452e900281ade00125578cda1fb04ad Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@opensource.altera.com>
Date: Wed, 11 Mar 2015 13:19:57 -0500
Subject: [PATCH] usb: dwc2: call dwc2_is_controller_alive() under spinlock

This patch fixes the following problem: data transmission in direction
IN break unless the GSNPSID register access is done with spinlock held.
This issue occurs at least in Exynos4412 SoC, probably in many SoC's
from Exynos familly.

The problem is described here:
https://lkml.org/lkml/2014/12/22/185
And there is linux mailing list discussion:
https://lkml.org/lkml/2015/1/14/17

Signed-off-by: Robert Baldyga <r.baldyga@samsung.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
[dinh: ported to 3.10-ltsi]
Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
---
 drivers/usb/dwc2/core_intr.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index 8685810..2d6fda2 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -469,12 +469,13 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 	int retry_count = 8;
 	irqreturn_t retval = IRQ_HANDLED;
 
+	spin_lock(&hsotg->lock);
+
 	if (dwc2_check_core_status(hsotg) < 0) {
 		dev_warn(hsotg->dev, "Controller is disconnected\n");
 		goto out;
 	}
 
-	spin_lock(&hsotg->lock);
 irq_retry:
 	gintsts = dwc2_read_common_intr(hsotg);
 	if (gintsts & ~GINTSTS_PRTINT)
@@ -611,8 +612,8 @@ irq_retry:
 	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
 		goto irq_retry;
 
-	spin_unlock(&hsotg->lock);
 out:
+	spin_unlock(&hsotg->lock);
 	return IRQ_RETVAL(retval);
 }
 EXPORT_SYMBOL_GPL(dwc2_handle_common_intr);
-- 
2.2.1

